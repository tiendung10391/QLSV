<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Understanding Cursor Types</title><meta name="Language" content="en-us" /><meta name="System.Keywords" content="cursor types" /><meta name="Microsoft.Help.Id" content="4f4d3db7-4f76-450d-ab63-141237a4f034" /><meta name="Description" content="Operations in a relational database act on a complete set of rows. The set of rows returned by a SELECT statement consists of all the rows that satisfy the conditions in the WHERE clause of the statement." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Understanding Cursor Types</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Operations in a relational database act on a complete set of rows. The set of rows returned by a SELECT statement consists of all the rows that satisfy the conditions in the WHERE clause of the statement. This complete set of rows returned by the statement is known as the result set. Applications cannot always work effectively with the entire result set as a unit. These applications need a mechanism to work with one row or a small block of rows at a time. Cursors are an extension to result sets that provide that mechanism. </p><p>Cursors extend result set processing by doing the following:</p><ul><li><p>Allowing positioning at specific rows of the result set.</p></li><li><p>Retrieving one row or block of rows from the current position in the result set.</p></li><li><p>Supporting data modifications to the row at the current position in the result set.</p></li><li><p>Supporting different levels of visibility to changes made by other users to the database data that is presented in the result set.</p></li></ul><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>For a full description of the SQL Server cursor types, see the "Cursor Types (Database Engine)" topic in SQL Server Books Online.</p></div><p>The JDBC specification provides support for forward-only and scrollable cursors that are sensitive or insensitive to changes made by other jobs, and can be read-only or updatable. This functionality is provided by the Microsoft JDBC Driver for SQL Server <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> class.</p></div><h1 class="heading">Remarks</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>The JDBC driver supports the following cursor types:</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>Result Set </p><p>(Cursor) Type</p></th><th><p>SQL Server Cursor Type</p></th><th><p>Characteristics</p></th><th><p>select</p><p>Method</p></th><th><p>response</p><p>Buffering</p></th><th><p>Description</p></th></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>N/A</p></td><td><p>Forward-only, read-only</p></td><td><p>direct</p></td><td><p>full</p></td><td><p>The application has to make a single (forward) pass through the result set. This is the default behavior and behaves the same as a TYPE_SS_DIRECT_FORWARD_ONLY cursor. The driver reads the entire result set from the server into a memory during the statement execution time. </p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>N/A</p></td><td><p>Forward-only, read-only</p></td><td><p>direct</p></td><td><p>adaptive</p></td><td><p>The application has to make a single (forward) pass through the result set. It behaves the same as a TYPE_SS_DIRECT_FORWARD_ONLY cursor. The driver reads rows from the server as the application requests them and thus minimizes the client-side memory usage.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_READ_ONLY)</p></td><td><p>Fast Forward</p></td><td><p>Forward-only, read-only</p></td><td><p>cursor</p></td><td><p>N/A</p></td><td><p>The application has to make a single (forward) pass through the result set by using a server cursor. It behaves the same as a TYPE_SS_SERVER_CURSOR_FORWARD_ONLY cursor.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_FORWARD_ONLY (CONCUR_UPDATABLE)</p></td><td><p>Dynamic (Forward-only)</p></td><td><p>Forward-only, updatable</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>The application has to make a single (forward) pass through the result set to update one or more rows. </p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p><p>By default, the fetch size is fixed when the application calls the <a href="233bf4f8-4758-42d0-a80b-33e34fa78027.htm">setFetchSize</a> method of the <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> object. </p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>The JDBC driver provides an adaptive buffering feature that allows you to retrieve statement execution results from the SQL Server as the application needs them, rather than all at once. For example, if the application should retrieve a large data that is too large to fit entirely in application memory, adaptive buffering allows the client application to retrieve such a value as a stream. </p><p>The default behavior of the driver is "<span sdata="langKeyword" value="adaptive"><span class="keyword">adaptive</span></span>". However, in order to get the adaptive buffering for the forward-only updatable result sets, the application has to explicitly call the <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> method of the <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> object by providing a <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> value "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. For an example code, see <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Updating Large Data Sample</a></span>.</p></div></td></tr><tr><td><p>TYPE_SCROLL_INSENSITIVE</p></td><td><p>Static</p></td><td><p>Scrollable, not updateable.</p><p>External row updates, inserts, and deletes are not visible.</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>The application requires a database snapshot. The result set is not updatable. Only CONCUR_READ_ONLY is supported.  All other concurrency types will cause an exception when used with this cursor type.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Keyset</p></td><td><p>Scrollable,  read-only. External row updates are visible, and deletes appear as missing data.</p><p>External row inserts are not visible. </p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>The application has to see changed data for existing rows only.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SCROLL_SENSITIVE</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Keyset</p></td><td><p>Scrollable, updatable. </p><p>External and internal row updates are visible, and deletes appear as missing data; inserts are not visible.</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>The application may change data in the existing rows by using the <b>ResultSet</b> object. The application must also be able to see the changes to rows made by others from outside the <b>ResultSet</b> object.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SS_DIRECT_FORWARD_ONLY</p></td><td><p>N/A</p></td><td><p>Forward-only, read-only</p></td><td><p>N/A</p></td><td><p>full or adaptive</p></td><td><p>Integer value = 2003. Provides a read-only client side cursor that is fully buffered. No server cursor is created.</p><p>Only CONCUR_READ_ONLY concurrency type is supported. All other concurrency types cause an exception when used with this cursor type.</p></td></tr><tr><td><p>TYPE_SS_SERVER_CURSOR_FORWARD_ONLY</p></td><td><p>Fast Forward</p></td><td><p>Forward-only</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>Integer value = 2004. Fast, accesses all data using a server cursor. It is updatable when used with CONCUR_UPDATABLE concurrency type.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p><p>In order to get the adaptive buffering for this case, the application has to explicitly call the <a href="9f489835-6cda-4c8c-b139-079639a169cf.htm">setResponseBuffering</a> method of the <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> object by providing a <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> value "<span sdata="langKeyword" value="adaptive&quot;"><span class="keyword">adaptive"</span></span>. For an example code, see <span sdata="link"><a href="76ecc05f-a77d-40a2-bab9-91a7fcf17347.htm">Updating Large Data Sample</a></span>.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_STATIC</p></td><td><p>Static</p></td><td><p>Other users’ updates are not reflected.</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>Integer value = 1004. Application requires a database snapshot. This is the SQL Server-specific synonym for the JDBC TYPE_SCROLL_INSENSITIVE and has the same concurrency setting behavior.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Keyset</p></td><td><p>Scrollable, read-only. External row updates are visible, and deletes appear as missing data.</p><p>External row inserts are not visible.</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>Integer value = 1005. Application has to see changed data for existing rows only. This is the SQL Server-specific synonym for the JDBC TYPE_SCROLL_SENSITIVE and has the same concurrency setting behavior.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_KEYSET</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Keyset</p></td><td><p>Scrollable, updatable. </p><p>External and internal row updates are visible, and deletes appear as missing data; inserts are not visible.</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>Integer value = 1005. Application has to change data or see changed data for existing rows. This is the SQL Server-specific synonym for the JDBC TYPE_SCROLL_SENSITIVE and has the same concurrency setting behavior.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_READ_ONLY)</p></td><td><p>Dynamic</p></td><td><p>Scrollable,  read-only. </p><p>External row updates and inserts are visible, and deletes appear as transient missing data in the current fetch buffer. </p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>Integer value = 1006. Application must see changed data for existing rows, and see inserted and deleted rows during the lifetime of the cursor.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr><tr><td><p>TYPE_SS_SCROLL_DYNAMIC</p><p>(CONCUR_UPDATABLE, CONCUR_SS_SCROLL_LOCKS, CONCUR_SS_OPTIMISTIC_CC, CONCUR_SS_OPTIMISTIC_CCVAL)</p></td><td><p>Dynamic</p></td><td><p>Scrollable, updatable. </p><p>External and internal row updates and inserts are visible, and deletes appear as transient missing data in the current fetch buffer.</p></td><td><p>N/A</p></td><td><p>N/A</p></td><td><p>Integer value = 1006. The application may change data for existing rows, or insert or delete rows by using the <b>ResultSet</b> object. The application must also be able to see changes, inserts, and deletes made by others from outside the <b>ResultSet</b> object.</p><p>Rows are retrieved from the server in blocks that are specified by the fetch size.</p></td></tr></table></div></div><h1 class="heading">Cursor Positioning</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>The TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, and TYPE_SS_SERVER_CURSOR_FORWARD_ONLY cursors support only the <a href="60248447-6908-4036-a779-a501453cd553.htm">next</a> positioning method.</p><p>The TYPE_SS_SCROLL_DYNAMIC cursor does not support the <a href="638e8148-8ca0-4e1f-9ec2-04a11bc9809b.htm">absolute</a> and <a href="a266e3bc-05c2-44e2-9346-125ae6780216.htm">getRow</a> methods. The <b>absolute</b> method can be approximated by a combination of calls to the <a href="67ed9447-7b10-4c87-98e7-f4c2e2470b3a.htm">first</a> and <a href="2bcdbb69-95fd-4ae8-8488-1a75a91fe2e0.htm">relative</a> methods for dynamic cursors.</p><p>The <b>getRow</b> method is supported by TYPE_FORWARD_ONLY, TYPE_SS_DIRECT_FORWARD_ONLY, TYPE_SS_SERVER_CURSOR_FORWARD_ONLY, TYPE_SS_SCROLL_KEYSET, and TYPE_SS_SCROLL_STATIC cursors only. The <b>getRow</b> method with all forward-only cursor types returns the number of rows read so far through the cursor.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>When an application makes an unsupported cursor positioning call, or an unsupported call to the <b>getRow</b> method, an exception is thrown with the message, "The requested operation is not supported with this cursor type."</p></div><p>Only the TYPE_SS_SCROLL_KEYSET and the equivalent TYPE_SCROLL_SENSITIVE cursors expose deleted rows. If the cursor is positioned on a deleted row, column values are unavailable, and the <a href="9c6db315-e614-4604-b020-41af6a214cc1.htm">rowDeleted</a> method returns "true". Calls to <b>get&lt;Type&gt;</b> methods throw an exception with the message, "Cannot get value from a deleted row". Deleted rows cannot be updated. If you try to call an <b>update&lt;Type&gt;</b> method on a deleted row, an exception is thrown with the message, "A deleted row cannot be updated". The TYPE_SS_SCROLL_DYNAMIC cursor has the same behavior until the cursor is moved out of the current fetch buffer.</p><p>Forward and dynamic cursors expose deleted rows in a similar way, but only while the cursors remain accessible in the fetch buffer. For forward cursors, this is fairly straightforward. For dynamic cursors it more complex when the fetch size is greater than 1. An application can move the cursor forward and backward within the window that is defined by the fetch buffer, but the deleted row will disappear when the original fetch buffer in which it was updated is left. If an application does not want to see transient deleted rows by using dynamic cursors, a fetch relative (0) should be used.</p><p>If the key values of a TYPE_SS_SCROLL_KEYSET or TYPE_SCROLL_SENSITIVE cursor row are updated with the cursor, the row retains its original position in the result set, regardless of whether the updated row meets the cursor’s selection criteria. If the row was updated outside the cursor, a deleted row will appear at the row’s original position, but the row will appear in the cursor only if another row with the new key values was present in the cursor, but has since been deleted. </p><p>For dynamic cursors, updated rows will retain their position within the fetch buffer until the window that is defined by the fetch buffer is left. Updated rows might subsequently reappear at different positions within the result set, or might disappear completely. Applications that have to avoid transient inconsistencies in the result set should use a fetch size of 1 (the default is 8 rows with CONCUR_SS_SCROLL_LOCKS concurrency and 128 rows with other concurrencies).</p></div><h1 class="heading">Cursor Conversion</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>SQL Server can sometimes choose to implement a cursor type other than the one requested, which is referred to as an implicit cursor conversion (or cursor degradation). For more information about implicit cursor conversion, see the "Using Implicit Cursor Conversions" topic in SQL Server Books Online.</p><p>With SQL Server 2000, when you update the data through the <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> and <b>ResultSet.CONCUR_UPDATABLE</b> result set, an exception is thrown with a message "The cursor is READ ONLY". This exception occurs because the SQL Server 2000 has done an implicit cursor conversion for that result set and did not return the updatable cursor that has been requested.</p><p>To work around this problem, you can do one of the following two solutions:</p><ul><li><p>Ensure that the underlying table has a primary key</p></li><li><p>Use <a href="d87afd89-3e75-402c-b844-1b434eb258df.htm">SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC</a> instead of <b>ResultSet.TYPE_SCROLL_SENSITIVE</b> while creating a statement.</p></li></ul></div><h1 class="heading">Cursor Updating</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>In-place updates are supported for cursors where the cursor type and concurrency support updates. If the cursor is not positioned on an updatable row in the result set (no <b>get&lt;Type&gt;</b> method call succeeded), a call to an <b>update&lt;Type&gt;</b> method will throw an exception with the message, "The result set has no current row." The JDBC specification states that an exception arises when an update method is called for a column of a cursor that is CONCUR_READ_ONLY. In situations where the row is not updatable, such as because of an optimistic concurrency conflict such as a competing update or deletion, the exception might not arise until <a href="363d1008-1396-4fc0-8e27-c9ba2499e7f1.htm">insertRow</a>, <a href="cfced0ca-a281-40dc-8d2f-370d5f0bf12b.htm">updateRow</a>, or <a href="aa04a644-c7c2-4738-8b6e-7fea566d2c16.htm">deleteRow</a> is called.</p><p>After a call to <b>update&lt;Type&gt;</b>, the affected column cannot be accessed by <b>get&lt;Type&gt;</b> until <b>updateRow</b> or <a href="2ecacca4-f7bc-4f5d-886a-da7747fdccae.htm">cancelRowUpdates</a> has been called. This avoids problems where a column is updated by using a different type from the type returned by the server, and subsequent getter calls could invoke client side type conversions that give inaccurate results. Calls to <b>get&lt;Type&gt;</b> will throw an exception with the message, "Updated columns cannot be accessed until updateRow() or cancelRowUpdates() has been called."</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>If the <b>updateRow</b> method is called when no columns have been updated, the JDBC driver will throw an exception with the message, "updateRow() called when no columns have been updated."</p></div><p>After <a href="f3c54bfe-d5b7-4f6e-ae6c-3e8954e5b1c9.htm">moveToInsertRow</a> has been called, an exception will be thrown if any method other than <b>get&lt;Type&gt;</b>, <b>update&lt;Type&gt;</b>, <b>insertRow,</b> and cursor positioning methods (including <a href="9a7c754c-2d72-4207-b3bd-2afc6047fb3d.htm">moveToCurrentRow</a>) are called on the result set. The <b>moveToInsertRow</b> method effectively places the result set into insert mode, and cursor positioning methods terminate insert mode. Relative cursor positioning calls move the cursor relative to the position it was at before <b>moveToInsertRow</b> was called. After cursor positioning calls, the eventual destination cursor position becomes the new cursor position.</p><p>If the cursor positioning call made while in insert mode does not succeed, the cursor position after the failed call is the original cursor position before <b>moveToInsetRow</b> was called. If <b>insertRow</b> fails, the cursor remains on the insert row and the cursor remains in insert mode.</p><p>Columns in the insert row are initially in an uninitialized state. Calls to the <b>update&lt;Type&gt;</b> method set the column state to initialized. A call to the <b>get&lt;Type&gt;</b> method for an uninitialized column throws an exception. A call to the <b>insertRow</b> method returns all the columns in the insert row to an uninitialized state.</p><p>If any columns are uninitialized when the <b>insertRow</b> method is called, the default value for the column is inserted. If there is no default value but the column is nullable, then NULL is inserted. If there is no default value and the column is not nullable, the server will return an error and an exception will be thrown.</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p /><p>Calls to the <b>getRow</b> method returns 0 when in insert mode. </p><p>The JDBC driver does not support positioned updates or deletes. According to the JDBC specification, the <a href="3f3ec4f2-103a-4e16-9206-c5bd8639f946.htm">setCursorName</a> method has no effect and the <a href="e5b3af67-423a-4551-a4c6-a4bc076bd504.htm">getCursorName</a> method will throw an exception if called. </p><p>Read-only and static cursors are never updatable. </p><p>SQL Server restricts server cursors to a single result set. If a batch or stored procedure contains multiple statements, then a forward-only read-only client cursor must be used.</p></div></div><span id="seeAlsoSpan"><h1 class="heading">See Also</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="9ed5ad41-22e0-4e4a-8a79-10512db60d50.htm">Managing Result Sets with the JDBC Driver</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Send <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','01.00.12024.10000','%0\dThank%20you%20for%20your%20feedback.%20The%20developer%20writing%20teams%20use%20your%20feedback%20to%20improve%20documentation.%20While%20we%20are%20reviewing%20your%20feedback,%20we%20may%20send%20you%20e-mail%20to%20ask%20for%20clarification%20or%20feedback%20on%20a%20solution.%20We%20do%20not%20use%20your%20e-mail%20address%20for%20any%20other%20purpose%20and%20we%20delete%20it%20after%20we%20finish%20our%20review.%0\AFor%20further%20information%20about%20the%20privacy%20policies%20of%20Microsoft,%20please%20see%20http://privacy.microsoft.com/en-us/default.aspx.%0\A%0\d','Customer%20Feedback');">feedback</a> on this topic to Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft.  All rights reserved.</a></p></span></div></div></body></html>