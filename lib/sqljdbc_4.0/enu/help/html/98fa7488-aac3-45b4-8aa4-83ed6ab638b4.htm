<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>Understanding Data Type Conversions</title><meta name="Language" content="en-us" /><meta name="System.Keywords" content="data type conversions" /><meta name="Microsoft.Help.Id" content="98fa7488-aac3-45b4-8aa4-83ed6ab638b4" /><meta name="Description" content="To facilitate the conversion of Java programming language data types to SQL Server data types, the Microsoft JDBC Driver for SQL Server provides data type conversions as required by the JDBC specification." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">Understanding Data Type Conversions</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>To facilitate the conversion of Java programming language data types to SQL Server data types, the Microsoft JDBC Driver for SQL Server provides data type conversions as required by the JDBC specification. For added flexibility, all types are convertible to and from <span sdata="langKeyword" value="Object"><span class="keyword">Object</span></span>, <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>, and <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span> data types. </p></div><h1 class="heading">Getter Method Conversions</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>Based on the SQL Server data types, the following chart contains the JDBC driver’s conversion map for the <b>get&lt;Type&gt;()</b> methods of the <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> class, and the supported conversions for the <b>get&lt;Type&gt;</b> methods of the <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> class.</p><img alt="JDBCGetterConversions" src="../art/JDBCGetterConversions.gif" /><p>There are three categories of conversions that are supported by the JDBC driver’s getter methods:</p><ul><li><p><span class="label">Non-Lossy (x)</span>: Conversions for cases where the getter type is the same or smaller than the underlying server type. For example, when calling <b>getBigDecimal</b> on an underlying server decimal column, no conversion is necessary.</p></li><li><p><span class="label">Converted (y)</span>: Conversions from numeric server types to Java language types where the conversion is regular and follows Java language conversion rules. For these conversions, precision is always truncated—never rounded—and overflow is handled as modulo of the destination type, which is smaller. For example, calling <b>getInt</b> on an underlying <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> column that contains "1.9999" will return "1", or if the underlying <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> value is "3000000000" then the <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> value overflows to "-1294967296".</p></li><li><p><span class="label">Data Dependent (z)</span>: Conversions from underlying character types to numeric types require that the character types contain values that can be converted into that type. No other conversions are performed. If the value is too large for the getter type, the value is not valid. For example, if <b>getInt</b> is called on a varchar(50) column that contains "53", the value is returned as an <span sdata="langKeyword" value="int"><span class="keyword">int</span></span>; but if the underlying value is "xyz" or "3000000000", an error is thrown.</p></li></ul><p>If <b>getString</b> is called on a <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, or <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> column data type, the value is returned as a hexadecimal string value.</p></div><h1 class="heading">Updater Method Conversions</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>For the Java typed data passed to the <b>update&lt;Type&gt;()</b> methods of the <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> class, the following conversions apply.</p><img alt="JDBCUpdaterConversions" src="../art/JDBC_JDBCUpdatterConversions.gif" /><p>There are three categories of conversions supported by the JDBC driver’s updater methods:</p><ul><li><p><span class="label">Non-Lossy (x)</span>: Conversions for cases where the updater type is the same or smaller than the underlying server type. For example, when calling <b>updateBigDecimal</b> on an underlying server decimal column, no conversion is necessary.</p></li><li><p><span class="label">Converted (y)</span>: Conversions from numeric server types to Java language types where the conversion is regular and follows Java language conversion rules. For these conversions, precision is always truncated (never rounded) and overflow is handled as modulo of the destination (the smaller) type. For example, calling <b>updateDecimal</b> on an underlying <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> column that contains "1.9999" will return "1", or if the underlying <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> value is "3000000000" then the <span sdata="langKeyword" value="int"><span class="keyword">int</span></span> value overflows to "-1294967296".</p></li><li><p><span class="label">Data Dependent (z)</span>: Conversions from underlying source data types to destination data types require that the contained values can be converted into the destination types. No other conversions are performed. If the value is too large for the getter type, the value is not valid. For example, if <b>updateString</b> is called on an int column that contains "53", the update succeeds; but if the underlying String value is "foo" or "3000000000", an error is thrown.</p></li></ul><p>When <b>updateString</b> is called on a <span sdata="langKeyword" value="binary"><span class="keyword">binary</span></span>, <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span>, <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span>, or <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> column data type, it handles the String value as a hexadecimal string value.</p><p>When the SQL Server column data type is <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, the data value must be a valid <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>. When calling <b>updateBytes</b>, <b>updateBinaryStream</b>, or <b>updateBlob</b> methods, the data value should be the hexadecimal string representation of the XML characters. For example: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Note that a byte-order mark (BOM) is required if the XML characters are in specific character encodings.</p></div><h1 class="heading">Setter Method Conversions</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>For the Java typed data passed to the <b>set&lt;Type&gt;()</b> methods of the <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> class and the <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> class, the following conversions apply.</p><img alt="JDBCSetterConversions" src="../art/JDBC_JDBCSetterConversions_v2.gif" /><p>The server tries any conversions and returns errors on failure.</p><p>In the case of the <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> data type, if the value exceeds the length of <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, it maps to <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Similarly, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> maps to <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> if the value exceeds the supported length of <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. The same is true for <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Values longer than <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> become <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>There are two categories of conversions that are supported by the JDBC driver’s setter methods:</p><ul><li><p><span class="label">Non-Lossy (x)</span>: Conversions for numeric cases where the setter type is the same or smaller than the underlying server type. For example, when calling <b>setBigDecimal</b> on an underlying server <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> column, no conversion is necessary. For numeric to character cases, the Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> data type is converted to a <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. For example, calling <b>setDouble</b> with a value of "53" on a varchar(50) column produces a character value "53" in that destination column.</p></li><li><p><span class="label">Converted (y)</span>: Conversions from a Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> type to an underlying server <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> type that is smaller. This conversion is regular and follows SQL Server conversion conventions. Precision is always truncated (never rounded) and overflow throws an unsupported conversion error. For example, using <b>updateDecimal</b> with a value of "1.9999" on an underlying integer column results in a "1" in the destination column; but if "3000000000" is passed, the driver throws an error.</p></li><li><p><span class="label">Data Dependent (z)</span>: Conversions from a Java <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> type to the underlying SQL Server data type depends on the following conditions: The driver sends the <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> value to SQL Server and SQL Server performs conversions, if necessary. If the <b>sendStringParametersAsUnicode</b> is set to true and the underlying SQL Server data type is <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server does not allow converting <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> to <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> and throws an <b>SQLServerException</b>. If the sendStringParametersAsUnicode is set to false and the underlying SQL Server data type is <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server allows converting <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> to <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> and does not throw an exception.</p></li></ul><p>SQL Server performs the conversions and passes errors back to the JDBC driver when there are problems.</p><p>When the SQL Server column data type is <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, the data value must be a valid <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>. When calling <b>updateBytes</b>, <b>updateBinaryStream</b>, or <b>updateBlob</b> methods, the data value should be the hexadecimal string representation of the XML characters. For example: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Note that a byte-order mark (BOM) is required if the XML characters are in specific character encodings.</p></div><h1 class="heading">Conversions on setObject</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>For the Java typed data passed to the <b>setObject(&lt;Type&gt;)</b> methods of the <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> class, the following conversions apply. </p><img alt="JDBCSetObjectConversions" src="../art/JDBC_JDBCSetObjectConversions.gif" /><p>The <b>setObject</b> method with no specified target type uses the default mapping. In the case of the <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> data type, if the value exceeds the length of <span sdata="langKeyword" value="VARCHAR"><span class="keyword">VARCHAR</span></span>, it maps to <span sdata="langKeyword" value="LONGVARCHAR"><span class="keyword">LONGVARCHAR</span></span>. Similarly, <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span> maps to <span sdata="langKeyword" value="LONGNVARCHAR"><span class="keyword">LONGNVARCHAR</span></span> if the value exceeds the supported length of <span sdata="langKeyword" value="NVARCHAR"><span class="keyword">NVARCHAR</span></span>. The same is true for <span sdata="langKeyword" value="byte[]"><span class="keyword">byte[]</span></span>. Values longer than <span sdata="langKeyword" value="VARBINARY"><span class="keyword">VARBINARY</span></span> become <span sdata="langKeyword" value="LONGVARBINARY"><span class="keyword">LONGVARBINARY</span></span>.</p><p>There are three categories of conversions that are supported by the JDBC driver’s setObject methods:</p><ul><li><p><span class="label">Non-Lossy (x)</span>: Conversions for numeric cases where the setter type is the same or smaller than the underlying server type. For example, when calling <b>setBigDecimal</b> on an underlying server <span sdata="langKeyword" value="decimal"><span class="keyword">decimal</span></span> column, no conversion is necessary. For numeric to character cases, the Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> data type is converted to a <span sdata="langKeyword" value="String"><span class="keyword">String</span></span>. For example, calling <b>setDouble</b> with a value of "53" on a varchar(50) column will produce a character value "53" in that destination column.</p></li><li><p><span class="label">Converted (y)</span>: Conversions from a Java <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> type to an underlying server <span sdata="langKeyword" value="numeric"><span class="keyword">numeric</span></span> type that is smaller. This conversion is regular and follows SQL Server conversion conventions. Precision is always truncated—never rounded—and overflow throws an unsupported conversion error. For example, using <b>updateDecimal</b> with a value of "1.9999" on an underlying integer column results in a "1" in the destination column; but if "3000000000" is passed, the driver throws an error.</p></li><li><p><span class="label">Data Dependent (z)</span>: Conversions from a Java <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> type to the underlying SQL Server data type depends on the following conditions: The driver sends the <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> value to SQL Server and SQL Server performs conversions, if necessary. If the <b>sendStringParametersAsUnicode</b> connection property is set to true and the underlying SQL Server data type is <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server does not allow converting <span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span> to <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> and throws an SQLServerException. If the <b>sendStringParametersAsUnicode</b> is set to false and the underlying SQL Server data type is <span sdata="langKeyword" value="image"><span class="keyword">image</span></span>, SQL Server allows converting <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> to <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> and does not throw an exception.</p></li></ul><p>SQL Server performs the bulk of the set conversions and passes errors back to the JDBC driver when there are problems. Client-side conversions are the exception and are performed only in the case of <span sdata="langKeyword" value="date"><span class="keyword">date</span></span>, <span sdata="langKeyword" value="time"><span class="keyword">time</span></span>, <span sdata="langKeyword" value="timestamp"><span class="keyword">timestamp</span></span>, <span sdata="langKeyword" value="Boolean"><span class="keyword">Boolean</span></span>, and <span sdata="langKeyword" value="String"><span class="keyword">String</span></span> values.</p><p>When the SQL Server column data type is <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>, the data value must be a valid <span sdata="langKeyword" value="XML"><span class="keyword">XML</span></span>. When calling setObject(byte[], SQLXML), setObject(inputStream, SQLXML), or setObject(Blob, SQLXML) methods, the data value should be the hexadecimal string representation of the XML characters. For example: </p><div class="sampleCode"><span codeLanguage="other"><pre>&lt;hello&gt;world&lt;/hello&gt; = 0x3C68656C6C6F3E776F726C643C2F68656C6C6F3E </pre></span></div><p>Note that a byte-order mark (BOM) is required if the XML characters are in specific character encodings.</p></div><span id="seeAlsoSpan"><h1 class="heading">See Also</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">Understanding the JDBC Driver Data Types</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">Send <a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','01.00.12024.10000','%0\dThank%20you%20for%20your%20feedback.%20The%20developer%20writing%20teams%20use%20your%20feedback%20to%20improve%20documentation.%20While%20we%20are%20reviewing%20your%20feedback,%20we%20may%20send%20you%20e-mail%20to%20ask%20for%20clarification%20or%20feedback%20on%20a%20solution.%20We%20do%20not%20use%20your%20e-mail%20address%20for%20any%20other%20purpose%20and%20we%20delete%20it%20after%20we%20finish%20our%20review.%0\AFor%20further%20information%20about%20the%20privacy%20policies%20of%20Microsoft,%20please%20see%20http://privacy.microsoft.com/en-us/default.aspx.%0\A%0\d','Customer%20Feedback');">feedback</a> on this topic to Microsoft.</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft.  All rights reserved.</a></p></span></div></div></body></html>